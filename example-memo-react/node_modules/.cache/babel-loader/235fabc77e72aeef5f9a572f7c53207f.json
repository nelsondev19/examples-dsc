{"ast":null,"code":"import{useRef,useEffect}from\"react\";export var useInfiniteScroll=function useInfiniteScroll(_ref){var element=_ref.element,fetch=_ref.fetch;var loader=useRef(fetch);var observer=useRef(new IntersectionObserver(function(entries){var first=entries[0];if(first.isIntersecting){loader.current();}},{threshold:1}));useEffect(function(){loader.current=fetch;},[fetch]);useEffect(function(){var currentElement=element;var currentObserver=observer.current;if(currentElement){currentObserver.observe(currentElement);}return function(){if(currentElement){currentObserver.unobserve(currentElement);}};},[element]);};","map":{"version":3,"sources":["/home/nelson/Escritorio/examples-dsc/example-memo-react/src/hooks/useInfiniteScroll.js"],"names":["useRef","useEffect","useInfiniteScroll","element","fetch","loader","observer","IntersectionObserver","entries","first","isIntersecting","current","threshold","currentElement","currentObserver","observe","unobserve"],"mappings":"AAAA,OAASA,MAAT,CAAiBC,SAAjB,KAAkC,OAAlC,CAEA,MAAO,IAAMC,CAAAA,iBAAiB,CAAG,QAApBA,CAAAA,iBAAoB,MAAwB,IAArBC,CAAAA,OAAqB,MAArBA,OAAqB,CAAZC,KAAY,MAAZA,KAAY,CACvD,GAAMC,CAAAA,MAAM,CAAGL,MAAM,CAACI,KAAD,CAArB,CAEA,GAAME,CAAAA,QAAQ,CAAGN,MAAM,CACrB,GAAIO,CAAAA,oBAAJ,CACE,SAACC,OAAD,CAAa,CACX,GAAMC,CAAAA,KAAK,CAAGD,OAAO,CAAC,CAAD,CAArB,CACA,GAAIC,KAAK,CAACC,cAAV,CAA0B,CACxBL,MAAM,CAACM,OAAP,GACD,CACF,CANH,CAOE,CAAEC,SAAS,CAAE,CAAb,CAPF,CADqB,CAAvB,CAYAX,SAAS,CAAC,UAAM,CACdI,MAAM,CAACM,OAAP,CAAiBP,KAAjB,CACD,CAFQ,CAEN,CAACA,KAAD,CAFM,CAAT,CAIAH,SAAS,CAAC,UAAM,CACd,GAAMY,CAAAA,cAAc,CAAGV,OAAvB,CACA,GAAMW,CAAAA,eAAe,CAAGR,QAAQ,CAACK,OAAjC,CAEA,GAAIE,cAAJ,CAAoB,CAClBC,eAAe,CAACC,OAAhB,CAAwBF,cAAxB,EACD,CAED,MAAO,WAAM,CACX,GAAIA,cAAJ,CAAoB,CAClBC,eAAe,CAACE,SAAhB,CAA0BH,cAA1B,EACD,CACF,CAJD,CAKD,CAbQ,CAaN,CAACV,OAAD,CAbM,CAAT,CAcD,CAjCM","sourcesContent":["import { useRef, useEffect } from \"react\";\n\nexport const useInfiniteScroll = ({ element, fetch }) => {\n  const loader = useRef(fetch);\n\n  const observer = useRef(\n    new IntersectionObserver(\n      (entries) => {\n        const first = entries[0];\n        if (first.isIntersecting) {\n          loader.current();\n        }\n      },\n      { threshold: 1 }\n    )\n  );\n\n  useEffect(() => {\n    loader.current = fetch;\n  }, [fetch]);\n\n  useEffect(() => {\n    const currentElement = element;\n    const currentObserver = observer.current;\n\n    if (currentElement) {\n      currentObserver.observe(currentElement);\n    }\n\n    return () => {\n      if (currentElement) {\n        currentObserver.unobserve(currentElement);\n      }\n    };\n  }, [element]);\n};"]},"metadata":{},"sourceType":"module"}